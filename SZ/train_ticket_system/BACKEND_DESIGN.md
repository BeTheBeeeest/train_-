# 火车票候补系统 - 后端设计文档

## 一、系统概述

### 1.1 系统简介
本系统后端采用Go语言开发，实现了完整的火车票候补购票功能。系统采用C/S架构，使用TCP协议进行网络通信，支持多客户端并发操作。

### 1.2 技术栈
- **开发语言**: Go 1.21+
- **并发控制**: sync.RWMutex（读写锁）
- **网络协议**: TCP
- **数据格式**: JSON
- **存储方式**: 内存存储（可扩展至数据库）

### 1.3 核心功能
- 车票查询
- 车票购买
- 候补队列管理
- 自动兑现机制
- 订单状态查询
- 退票处理

## 二、数据模型设计

### 2.1 核心类图

```
┌─────────────────────────────────────────────────────────────┐
│                      TicketSystem                           │
├─────────────────────────────────────────────────────────────┤
│ - mu: RWMutex                                              │
│ - Train: *Train                                            │
│ - WaitQueue: []*WaitOrder                                  │
│ - Orders: map[string]*WaitOrder                            │
│ - OrderCount: int                                          │
├─────────────────────────────────────────────────────────────┤
│ + QueryTicket(): *Train                                    │
│ + BuyTicket(passenger: Passenger): (bool, string)          │
│ + AddToWaitList(req: WaitRequest): *WaitOrder              │
│ + CheckWaitPosition(orderID: string): (*WaitOrder, bool)   │
│ + ProcessRefund()                                          │
└─────────────────────────────────────────────────────────────┘
                            │
                            │ 包含
                            ▼
        ┌───────────────────────────────────┐
        │           Train                    │
        ├───────────────────────────────────┤
        │ + ID: string                      │
        │ + From: string                    │
        │ + To: string                      │
        │ + Total: int                      │
        │ + Sold: int                       │
        │ + Date: string                    │
        └───────────────────────────────────┘
                            │
                            │ 管理
                            ▼
        ┌───────────────────────────────────┐
        │         WaitOrder                  │
        ├───────────────────────────────────┤
        │ + OrderID: string                 │
        │ + Passenger: Passenger            │
        │ + TrainID: string                 │
        │ + Date: string                    │
        │ + CreateTime: time.Time           │
        │ + Position: int                   │
        │ + Status: string                  │
        └───────────────────────────────────┘
                            │
                            │ 包含
                            ▼
        ┌───────────────────────────────────┐
        │         Passenger                  │
        ├───────────────────────────────────┤
        │ + ID: string                      │
        │ + Name: string                    │
        └───────────────────────────────────┘
```

### 2.2 数据结构说明

#### TicketSystem（票务系统）
**职责**: 系统核心类，管理所有票务操作和候补队列

**属性**:
- `mu: RWMutex` - 读写锁，保证并发安全
- `Train: *Train` - 车次信息指针
- `WaitQueue: []*WaitOrder` - 候补队列（FIFO）
- `Orders: map[string]*WaitOrder` - 订单映射表（订单号 → 订单对象）
- `OrderCount: int` - 订单计数器，用于生成唯一订单号

**核心方法**:
- `QueryTicket() *Train` - 查询余票信息（读锁）
- `BuyTicket(Passenger) (bool, string)` - 购买车票（写锁）
- `AddToWaitList(WaitRequest) *WaitOrder` - 加入候补队列（写锁）
- `CheckWaitPosition(string) (*WaitOrder, bool)` - 查询候补位置（读锁）
- `ProcessRefund()` - 处理退票并触发自动兑现（写锁）

#### Train（车次）
**职责**: 存储车次基本信息和票务状态

**属性**:
- `ID: string` - 车次号（如"G1001"）
- `From: string` - 出发地
- `To: string` - 目的地
- `Total: int` - 总票数
- `Sold: int` - 已售票数
- `Date: string` - 乘车日期

**计算属性**:
- 余票数 = Total - Sold

#### WaitOrder（候补订单）
**职责**: 存储候补订单的完整信息

**属性**:
- `OrderID: string` - 订单号（格式："W" + 时间戳）
- `Passenger: Passenger` - 乘客信息
- `TrainID: string` - 车次号
- `Date: string` - 乘车日期
- `CreateTime: time.Time` - 创建时间
- `Position: int` - 排队位置（从1开始）
- `Status: string` - 订单状态

**状态枚举**:
- `waiting` - 等待中
- `success` - 已兑现
- `failed` - 已失败

#### Passenger（乘客）
**职责**: 存储乘客基本信息

**属性**:
- `ID: string` - 乘客身份证号
- `Name: string` - 乘客姓名

#### WaitRequest（候补请求）
**职责**: 封装客户端提交的候补请求

**属性**:
- `Passenger: Passenger` - 乘客信息
- `TrainID: string` - 车次号
- `Date: string` - 乘车日期

### 2.3 数据关系

```
TicketSystem (1) ──────> (1) Train
      │                       [一对一]
      │
      ├──────> (0..*) WaitQueue
      │                [一对多：候补队列]
      │
      └──────> (0..*) Orders [map]
                       [一对多：订单映射]

WaitOrder (1) ──────> (1) Passenger
                      [一对一]

WaitRequest (1) ──────> (1) Passenger
                       [一对一]
```

## 三、业务流程设计

### 3.1 购票流程活动图

```
        开始
         │
         ▼
    ┌─────────┐
    │ 查询余票 │
    └────┬────┘
         │
         ▼
    ┌─────────┐
    │ 有余票？ │
    └────┬────┘
         │
    ┌────┴────┐
    │         │
   是         否
    │         │
    ▼         ▼
┌────────┐ ┌──────────┐
│ 直接购票│ │提示无票   │
└───┬────┘ └────┬─────┘
    │           │
    │           ▼
    │      ┌──────────┐
    │      │选择候补？ │
    │      └────┬─────┘
    │           │
    │      ┌────┴────┐
    │      │         │
    │     是         否
    │      │         │
    │      ▼         ▼
    │  ┌────────┐ ┌──────┐
    │  │加入候补│ │ 结束 │
    │  └───┬────┘ └──────┘
    │      │
    └──────┴──────┐
                  │
                  ▼
              ┌────────┐
              │购票成功 │
              └───┬────┘
                  │
                  ▼
                 结束
```

**流程说明**:
1. 客户端请求查询余票
2. 服务器返回余票信息
3. 如有余票，直接购票；无余票则提示
4. 用户可选择加入候补队列
5. 购票成功后更新已售票数

### 3.2 候补功能活动图

```
                    开始
                     │
                     ▼
              ┌─────────────┐
              │ 接收候补请求 │
              └──────┬──────┘
                     │
                     ▼
              ┌─────────────┐
              │ 验证信息完整 │
              └──────┬──────┘
                     │
                ┌────┴────┐
                │         │
              有效       无效
                │         │
                │         ▼
                │    ┌─────────┐
                │    │返回错误  │
                │    └────┬────┘
                │         │
                │         ▼
                │       结束
                │
                ▼
         ┌─────────────┐
         │ 生成订单号   │
         │ W+时间戳     │
         └──────┬──────┘
                │
                ▼
         ┌─────────────┐
         │ 创建订单对象 │
         └──────┬──────┘
                │
                ▼
         ┌─────────────┐
         │ 加入候补队列 │
         │ (append)     │
         └──────┬──────┘
                │
                ▼
         ┌─────────────┐
         │ 计算排队位置 │
         │ (队列长度)   │
         └──────┬──────┘
                │
                ▼
         ┌─────────────┐
         │ 保存到映射表 │
         │ Orders[id]   │
         └──────┬──────┘
                │
                ▼
         ┌─────────────┐
         │ 返回订单信息 │
         └──────┬──────┘
                │
                ▼
               结束
```

**流程说明**:
1. 接收客户端候补请求
2. 验证乘客信息完整性
3. 生成唯一订单号
4. 创建WaitOrder对象
5. 追加到候补队列末尾
6. 计算排队位置
7. 保存到订单映射表
8. 返回订单信息给客户端

### 3.3 退票与候补兑现活动图

```
                    开始
                     │
                     ▼
              ┌─────────────┐
              │ 接收退票请求 │
              └──────┬──────┘
                     │
                     ▼
              ┌─────────────┐
              │ 减少已售票数 │
              │ Sold--       │
              └──────┬──────┘
                     │
                     ▼
              ┌─────────────┐
              │候补队列为空？│
              └──────┬──────┘
                     │
                ┌────┴────┐
                │         │
               是         否
                │         │
                │         ▼
                │  ┌─────────────┐
                │  │ 获取队首订单 │
                │  │ WaitQueue[0] │
                │  └──────┬──────┘
                │         │
                │         ▼
                │  ┌─────────────┐
                │  │ 自动购票     │
                │  │ Sold++       │
                │  └──────┬──────┘
                │         │
                │         ▼
                │  ┌─────────────┐
                │  │更新订单状态  │
                │  │Status=success│
                │  └──────┬──────┘
                │         │
                │         ▼
                │  ┌─────────────┐
                │  │从队列中移除  │
                │  │WaitQueue[1:]│
                │  └──────┬──────┘
                │         │
                │         ▼
                │  ┌─────────────┐
                │  │更新其他订单  │
                │  │Position--   │
                │  └──────┬──────┘
                │         │
                │         ▼
                │  ┌─────────────┐
                │  │ 记录日志     │
                │  └──────┬──────┘
                │         │
                └─────────┴──────┐
                                 │
                                 ▼
                          ┌─────────────┐
                          │ 退票完成     │
                          └──────┬──────┘
                                 │
                                 ▼
                                结束
```

**自动兑现机制说明**:
1. 退票时减少已售票数
2. 检查候补队列是否为空
3. 如队列不为空，取队首订单
4. 为该订单自动购票（Sold++）
5. 更新订单状态为success
6. 从队列中移除该订单
7. 更新其他订单的排队位置
8. 整个过程在写锁保护下原子执行

### 3.4 查询候补状态活动图

```
        开始
         │
         ▼
    ┌─────────┐
    │接收订单号│
    └────┬────┘
         │
         ▼
    ┌─────────┐
    │查询映射表│
    │Orders[id]│
    └────┬────┘
         │
    ┌────┴────┐
    │         │
  存在       不存在
    │         │
    ▼         ▼
┌────────┐ ┌──────────┐
│获取订单 │ │返回错误   │
│对象     │ └────┬─────┘
└───┬────┘      │
    │           │
    ▼           ▼
┌────────┐    结束
│查找队列 │
│位置     │
└───┬────┘
    │
    ▼
┌────────┐
│更新排队 │
│位置     │
└───┬────┘
    │
    ▼
┌────────┐
│返回订单 │
│信息     │
└───┬────┘
    │
    ▼
   结束
```

**查询逻辑**:
1. 通过订单号在Orders映射表中查找
2. 时间复杂度O(1)
3. 动态计算当前排队位置
4. 返回完整订单信息

## 四、并发控制设计

### 4.1 读写锁机制

系统使用 `sync.RWMutex` 实现细粒度的并发控制：

```go
type TicketSystem struct {
    mu         sync.RWMutex
    Train      *Train
    WaitQueue  []*WaitOrder
    Orders     map[string]*WaitOrder
    OrderCount int
}
```

**读操作（允许并发）**:
```
- QueryTicket()         // 查询余票
- CheckWaitPosition()   // 查询候补位置
```

**写操作（互斥执行）**:
```
- BuyTicket()          // 购买车票
- AddToWaitList()      // 加入候补
- ProcessRefund()      // 退票处理
```

### 4.2 并发场景分析

#### 场景1: 多客户端同时购票
```
时间线:
t1: 客户端A获取写锁 ──> BuyTicket() ──> 释放写锁
t2:     客户端B等待写锁 ──────────────┐
t3:     客户端C等待写锁 ──────────────┤
t4:                                   ├──> B获取写锁 ──> 释放
t5:                                   └──> C等待
t6:                                       C获取写锁 ──> 释放
```

**保证**: 票数变更的原子性和一致性

#### 场景2: 读写并发
```
客户端A ──> [写锁] BuyTicket()
              │
              ├──> 修改Sold
              │
              └──> [解锁]
                    │
客户端B ──> [读锁] QueryTicket()
              │
              ├──> 读取Sold
              │
              └──> [解锁]

说明：读操作等待写操作完成，保证读到最新数据
```

#### 场景3: 退票触发候补兑现
```
客户端A ──> [写锁] ProcessRefund()
              │
              ├──> Sold--
              │
              ├──> 检查WaitQueue
              │
              ├──> 取队首订单
              │
              ├──> Sold++
              │
              ├──> 更新订单状态
              │
              ├──> 移除队首
              │
              ├──> 更新位置
              │
              └──> [解锁]

说明：整个兑现过程在一个写锁内完成，保证原子性
```

### 4.3 死锁预防

**策略**:
1. 单一锁对象，避免多锁竞争
2. 按固定顺序加锁
3. 及时释放锁
4. 使用defer确保锁释放

```go
func (ts *TicketSystem) BuyTicket(p Passenger) (bool, string) {
    ts.mu.Lock()
    defer ts.mu.Unlock()  // 确保释放
    
    // 业务逻辑
    if ts.Train.Sold >= ts.Train.Total {
        return false, "无余票"
    }
    ts.Train.Sold++
    return true, "购票成功"
}
```

## 五、状态转换设计

### 5.1 候补订单状态转换

```
    [创建订单]
        │
        ▼
   ┌─────────┐
   │ waiting │
   │ (等待中) │
   └────┬────┘
        │
   ┌────┴────┐
   │         │
  有退票    超时
   │         │
   ▼         ▼
┌────────┐ ┌────────┐
│success │ │ failed │
│(已兑现)│ │(已失败)│
└────────┘ └────────┘
   [终态]     [终态]
```

**状态说明**:
- `waiting`: 初始状态，在队列中等待
- `success`: 终态，自动兑现成功
- `failed`: 终态，兑现失败（可扩展超时机制）

**状态转换条件**:
- waiting → success: 有退票且为队首
- waiting → failed: 超时或取消（当前未实现）

### 5.2 票务系统状态

```
初始状态: 
├── Sold = 0
├── WaitQueue = []
└── Orders = {}

购票操作:
└── Sold++

退票操作:
├── Sold--
└── if WaitQueue不为空:
    ├── WaitQueue[0].Status = "success"
    ├── WaitQueue = WaitQueue[1:]
    └── Sold++
```

## 六、网络通信协议

### 6.1 消息格式

**请求消息**:
```json
{
    "type": "操作类型",
    "data": {
        // 具体数据
    }
}
```

**响应消息**:
```json
{
    "success": true/false,
    "message": "提示信息",
    "data": {
        // 返回数据
    }
}
```

### 6.2 消息类型定义

| 类型 | 说明 | 请求数据 | 响应数据 |
|------|------|---------|---------|
| `query_ticket` | 查询余票 | 无 | Train对象 |
| `buy_ticket` | 购买车票 | Passenger | 成功/失败 |
| `wait_list` | 加入候补 | WaitRequest | WaitOrder |
| `check_wait` | 查询候补 | orderID | WaitOrder |
| `refund` | 退票 | 无 | 成功/失败 |

### 6.3 通信流程

```
客户端                      服务器
  │                          │
  ├──> 建立TCP连接 ──────────>│
  │                          │
  ├──> 发送JSON请求 ────────>│
  │                          │
  │                   处理请求 │
  │                   ↓      │
  │                   加锁    │
  │                   ↓      │
  │                  业务逻辑 │
  │                   ↓      │
  │                   解锁    │
  │                   ↓      │
  │<──── 返回JSON响应 ────────┤
  │                          │
```

## 七、安全性设计

### 7.1 并发安全
- ✅ 使用RWMutex保护所有共享数据
- ✅ 原子操作保证数据一致性
- ✅ 避免死锁的设计模式

### 7.2 数据验证
- ✅ 乘客信息完整性检查（ID和Name非空）
- ✅ 订单号有效性验证
- ✅ 余票数量边界检查

### 7.3 错误处理
- ✅ 网络异常处理
- ✅ JSON解析错误处理
- ✅ 业务逻辑错误返回

### 7.4 安全建议
- 🔸 添加身份认证机制
- 🔸 添加请求频率限制
- 🔸 添加数据加密传输
- 🔸 添加操作日志审计

## 八、性能优化

### 8.1 数据结构优化
- **候补队列**: 使用切片实现，append操作O(1)
- **订单映射**: 使用map实现，查询操作O(1)
- **排队位置**: 动态计算，避免存储冗余

### 8.2 并发性能
- **读写分离**: 查询操作使用读锁，允许并发
- **锁粒度**: 单一锁对象，简化并发控制
- **快速释放**: defer确保及时释放锁

### 8.3 内存优化
- 订单对象使用指针，减少内存拷贝
- 队列使用切片而非链表，内存连续访问

### 8.4 性能指标
- 查询操作: < 1ms
- 购票操作: < 5ms
- 候补操作: < 10ms
- 支持并发: 100+ 客户端

## 九、扩展性设计

### 9.1 可扩展点

**1. 数据持久化**
```go
// 添加数据库接口
type Storage interface {
    SaveOrder(*WaitOrder) error
    LoadOrders() ([]*WaitOrder, error)
    UpdateOrderStatus(string, string) error
}
```

**2. 多车次支持**
```go
type TicketSystem struct {
    mu     sync.RWMutex
    Trains map[string]*Train  // 车次ID -> 车次对象
    // ...
}
```

**3. 座位类型**
```go
type Train struct {
    // ...
    SeatTypes map[string]int  // 座位类型 -> 数量
}
```

**4. 超时机制**
```go
type WaitOrder struct {
    // ...
    ExpireTime time.Time  // 过期时间
}
```

**5. 通知系统**
```go
type Notifier interface {
    NotifySuccess(orderID string) error
    NotifyFailed(orderID string) error
}
```

### 9.2 架构演进

```
当前架构: 单机内存存储
  ├── 简单直接
  ├── 性能高
  └── 适合学习和演示

优化方向: 数据库持久化
  ├── 数据安全
  ├── 支持重启恢复
  └── 支持数据分析

进阶方向: 分布式架构
  ├── 票务服务集群
  ├── 候补服务集群
  ├── 消息队列
  └── 分布式缓存
```

## 十、测试建议

### 10.1 单元测试
- 测试并发购票
- 测试候补队列
- 测试自动兑现
- 测试边界条件

### 10.2 压力测试
- 100并发客户端
- 1000次购票操作
- 测试锁竞争
- 测试内存使用

### 10.3 功能测试
- 正常购票流程
- 候补加入流程
- 自动兑现流程
- 异常处理流程

## 十一、部署说明

### 11.1 环境要求
- Go 1.21+
- 无外部依赖
- 支持Windows/Linux/MacOS

### 11.2 启动方式
```bash
cd server
go run main.go
```

### 11.3 配置项
- 监听端口: 8080（可配置）
- 初始票数: 100（可配置）
- 车次信息: 可通过配置文件加载

## 十二、总结

本后端系统通过合理的数据结构设计、严格的并发控制和清晰的业务流程，实现了完整的火车票候补功能。系统具有：

✅ **高并发**: 支持多客户端并发操作
✅ **数据安全**: 严格的锁机制保证数据一致性
✅ **自动化**: 退票自动触发候补兑现
✅ **可扩展**: 良好的接口设计，易于扩展
✅ **高性能**: 优化的数据结构，快速响应

系统为学习和实践提供了良好的参考实现，同时也为实际生产环境提供了扩展方向。
